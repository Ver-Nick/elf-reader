**Описание системы кодирования команд RISC-V** 

**ISA** - архитектура набора команд, определяющая системную реализацию работы процессора. 

**RISC-V** — реализация **ISA**, расширяемая открытая и свободная система команд  и  процессорная  архитектура  на  основе  концепции  **RISC**  для микропроцессоров и микроконтроллеров. В архитектуре **RISC-V** имеется обязательное для реализации небольшое подмножество команд и несколько стандартных опциональных расширений. 

**Базовые наборы** 

- RV32I — Базовый набор с целочисленными операциями, 32-битный 
- RV64I — Базовый набор с целочисленными операциями, 64-битный 
- RV32E  —  Базовый  набор  с  целочисленными  операциями  для встраиваемых систем, 32-битный 
- RV128I  —  Базовый  набор  с  целочисленными  операциями,  128-

  битный 

**Некоторые дополнительные расширения наборов** 

- ~M — Целочисленное умножение и деление 
- ~A — Атомарные операции (то есть операции, которые не могут быть выполнены частично; они либо выполняются, либо нет) 
- ~F — Арифметические операции с плавающей запятой над числами одинарной точности 
- ~D — Арифметические операции с плавающей запятой над числами 

  двойной точности 

- ~Q — Арифметические операции с плавающей запятой над числами четверной точности 
- ~L  —  Арифметические  операции  с  плавающей  запятой  над десятичными числами 
- ~C — Набор с сокращенными названиями команд 
- ~B — Битовые операции 
- ~J — Набор с эмуляцией набора команд с поддержкой динамической компиляцией во время запуска 
- ~P — SIMD-операции 
- ~V — Векторная обработка данных (параллельно для скорости) 

**Наборы RV32I и RV32M** 

RV32I — базовый набор для работы с 32-битными числами, включает 39 целочисленных инструкций. Эти инструкции делят на группы: *R*, *I*, *S*, *B*, *J*, *U*. У каждой группы свой отдельный идентификатор, записанный в виде нескольких  бит  в  конце  каждой  команды,  а  также  отдельная  структура описания инструкции. 

Выполняемая программа имеет доступ к 32 регистрам с разными именами, с которыми может выполнять необходимые задачи. 

Инструкции могут (Рис. 1): 

- Совершить  операцию  с  двумя  регистрами,  записать  результат  в третий; 
- Совершить операцию с регистром и константой, записать результат в регистр; 
- Загрузить часть регистра из памяти; 
- Записать часть регистра в память; 
- Перейти к заданной инструкции, если заданное условие выполняется; 
- Перейти к заданной инструкции; 
- Приостановить  выполнение  и  передать  контроль  операционной системе или отладчику. 

![](Aspose.Words.031147f8-779d-43e0-a2f5-e373dd9c70b5.001.jpeg)

Рис.1: Все инструкции базового набора RV32I. 

RV32M  —  стандартное  расширение  к  базовому  набору  RV32I, добавляет функционал работы с умножением и делением. Даёт операции умножения, остатка, деления нацело (Рис. 2). 

![](Aspose.Words.031147f8-779d-43e0-a2f5-e373dd9c70b5.002.jpeg)

Рис.2: Инструкции расширения RV32M. 

**Представление инструкций** 

В памяти все инструкции RV32I и RV32M представляются в виде 32 бит. То, как именно они представляются, зависит от их типа **FMT** и заданной этому типу структуре (см. Рис. 3) 

![](Aspose.Words.031147f8-779d-43e0-a2f5-e373dd9c70b5.003.jpeg)

Рис.3: Структура инструкций 

В целом, почти все инструкции в **RISC-V** задаются в виде 32 бит, кроме расширения RV32C, который сокращает инструкции до 16 бит. 

Сама инструкция может быть определена по идентификатору группы **opcode** и значению **funct3** (в случае R-типа — дополнительно по значению **funct7**, так как количество инструкций в этой группе превышает лимит **funct3**). Всё задается в формате *little-endian*, то есть чтобы можно было прочитать инструкцию в формате слева направо как на табличке, четыре байта нужно повернуть в обратном порядке (**0X**232EF4FC -> **0X**FCF42E23). Поля  **rs1**  и  **rs2**  представляют  собой  регистры  (\*адреса  регистров)  над которыми  производятся  операции,  **rd  —**  регистр  для  записи  результата работы операции над **rs1** и **rs2**. Поле **imm** в зависимости от типа может представлять  собой  как  константу  для  совершения  с  ней  операции  над регистром,  так  и  значение, на  которое  должен  быть  совершен  переход, например в операциях типа *B* и *J.* 

Регистры, над которыми совершают операции имеют свои имена и предназначение (см. Рис. 4). Первые 16 идут в использование набору RV32I, остальные 16 предназначены для работы с нецелыми числами, например для  расширений  RV32F  или  RV32F,  поэтому  здесь  рассматриваться  не будут. 

Поле **imm** имеет такую странную структуру с разными частями в совершенно разных позициях инструкции по той причине, что на уровне аппаратной  реализации  эти  значения  извлекает  мультиплексор;  данная реализация помогает уменьшить количество раз, которое мультиплексор затрачивает  на  получение  значений,  уменьшая  коллизии  битов; соответственно  в  некоторых  случаях  можно  однозначно  определить некоторые биты, не прочитав их, по другим уже прочитанным битам. Это в итоге повышает общую производительность. 

![](Aspose.Words.031147f8-779d-43e0-a2f5-e373dd9c70b5.004.jpeg)

Рис.4: имена регистров, их идентификаторы в полях **rs1**, **rs2** и **rd** 

**ELF файлы** 

*Эльфы, Старшие Дети этого мира, были племенем прекрасным и благородным; владыками их были Эльдар, ныне покинувшие эту землю, – Народ Великого Перехода, Народ Звёзд. (c) Властелин Колец* 

**ELF —** формат исполняемых двоичных файлов, используемый во многих современных UNIX-подобных операционных системах, таких как FreeBSD, Linux и Solaris. 

Обычно ELF делится на два типа — один для 32-разрядной архитектуры и второй, позже появившийся, для 64-битной. Здесь мы будем рассматривать 32-разрядную архитектуру. 

**Заголовок файла** 

В 32-битной реализации состоит из 52 байт, описывает самые важные поля, такие как начало выполняемого кода, начало полей с информацией и количество этой информации: 

- *e\_ident*  —  содержит  некоторую  информацию  по  файлу  и архитектуре. Первые четыре байта обязаны быть 0x7f, 0x45, 0x4c и 0x46, иначе нас обманули и это не ELF файл;* 
- *e\_type* — тип исполняемого файла;* 
- *e\_machine* — тип архитектуры, для реализации RISC-V будет 0xF3;* 
- *e\_version* — версия, на данный момент всегда 1;* 
- *e\_entry —* адрес, откуда начинается выполнение файла;* 
- *e\_phoff —* позиция таблицы заголовков программы (в данной работе  эта  таблица  не  нужна,  но  необходима  операционной системе для подготовки к запуску);* 
- *e\_shoff —* позиция таблицы заголовков секций; 
- *e\_flags  —*  связанные  с  файлом  флаги  для  использования 

  процессором;* 

- *e\_ehsize —* размер заголовка файла, для 32-битной реализации равен 52;* 
- *e\_phentsize —* размер одного заголовка программы;* 
- *e\_phnum —* число заголовков программы;* 
- *e\_shentsize —* размер одного заголовка секции;* 
- *e\_shnum —* число заголовков секции;* 
- *e\_shstrndx  —*  индекс  записи  в  таблице  заголовков  секций, описывающей таблицу названий секций. 

**Таблица заголовков секций** 

Таблица  заголовков  секций  содержит  атрибуты  секций  файла.  Секции передают  информацию,  либо  для  исполнения,  либо  для  использования другими  секциями.  Каждый  заголовок  секции  описывает  отдельную секцию: 

- *sh\_name* — указатель на имя секции в таблице названий секций, о ней будет сказано позже;* 
- *sh\_type* — тип секции;* 
- *sh\_flags* — атрибуты секции;* 
- *sh\_addr*  —  при  необходимости  предварительной  загрузки секции указывает адрес, куда её можно загрузить;* 
- *sh\_offset* — расположение секции относительно начала файла;* 
- *sh\_size* — размер секции в байтах;* 
- *sh\_link* — индекс ассоциированной секции;* 
- *sh\_info* — другая дополнительная информация;* 
- *sh\_addralign* — выравнивание секции;* 
- *sh\_entsize —* размер в байтах каждого элемента в секции.* 

**Секции** 

Секции описывают различные части файла, в итоге формируя исполняемый файл. Сфокусируемся на *.strtab*, *.symtab* и *.text*: 

- *.strtab* — содержит список строк, разделенных нулями. Эти строки являются именами секций и именами символов из секции *.symtab*, представленных в заданном ELF файле. Именно в этой секции другие секции указывают на своё имя полем *sh\_name.* 
- *.symtab* —   в  этой  секции  содержатся  все  символы,  которые компоновщик использует как во время компиляции, так и во время выполнения  приложения.  В  реализации  32-битного  ELF  файла содержит 16-байтные структуры, называемые символами и имеющие имя, значение, размер и другую информацию. Инструкции RISC-V в итоге используют эти символы для описания блока функции. 
- *.text*  —  сама  исполняемая  программа;  содержит  4-байтные  блоки инструкций,  в  данном  случае  инструкции  заданы  в  системе кодирования **RISC-V**.  

**Описание работы написанного кода** 

**Общее описание** 

Код был написан на Java с использованием JDK 19. 

Все важные части: инструкции, секции, символы, заголовки описаны своими  классами  и  при  создании  достают  по  заданному  адресу информацию о себе и записывают для дальнейшего использования. Также описан  общий  класс  Pair  для  удобства,  так  как,  к  сожалению,  язык  не поддерживает данную структуру в отличие от C++. 

Все описываемые файлы находятся на одном уровне с запускаемым файлом Main.java. 

Существует ещё один файл, Constants.java, содержащий необходимые переменные, константы, словари, к которым исполняемый код обращается по мере надобности. Тут же и описана функция extractBytes, которая читает информацию из файла в формате little-endian: 
```
public static long extractBytes(long offset, long byteNum) throws Exception { 

    if (byteNum <= 0 || byteNum > 4) { 

        throw new Exception("Wrong number of bytes to read in extractBytes()");     } 

    long result = 0; 

    for(long i = 0; i < byteNum; i++){ 

        if (offset + byteNum - i - 1 < 0 || offset + byteNum - i - 1 >= *TOTAL*) {             throw new Exception("Index out of boundaries when trying to read in extractBytes()"); 

        } 

        result = result \* 256 + (*bytes*[(int) (offset + byteNum - i - 1)]); 

    } 

    return result; 
} 
```
Эта  функция  используется,  например  в  классе  Header.java  для читания ELF файла: 
```
public Header() throws Exception { 

    e\_type = Constants.*extractBytes*(16, 2); 

    e\_machine = Constants.*extractBytes*(18, 2);     e\_version = Constants.*extractBytes*(20, 4);     e\_entry = Constants.*extractBytes*(24, 4); 

    e\_phoff = Constants.*extractBytes*(28, 4); 

    e\_shoff = Constants.*extractBytes*(32, 4); 

    e\_flags = Constants.*extractBytes*(36, 4); 

    e\_ehsize = Constants.*extractBytes*(40, 2); 

    e\_phentsize = Constants.*extractBytes*(42, 2);     e\_phnum = Constants.*extractBytes*(44, 2); 

    e\_shentsize = Constants.*extractBytes*(46, 2);     e\_shnum = Constants.*extractBytes*(48, 2); 

    e\_shstrndx = Constants.*extractBytes*(50, 2); 
} 
```
Ещё есть функция для преобразования беззнакового типа в знаковый, используется для преобразования поля **imm:** 
```
public static long immToSigned(long n, long where){     if ((n & (1L << (where - 1))) != 0) { 

        return (n | -(1L << where)); 

    } 

    else { 

        return n; 

    } 

} 
```
И функция которая помогает выделить необходимые биты из данных: 
```
public static long cutInstruction(long bin, long from, long to) {     bin = bin & ((1L << (from + 1)) - 1); 

    bin = bin & (-(1L << to)); 

    return (bin >> to); 

} 
```
Также  в  Constants.java  описаны  словари  для  каждого  **FMT**  типа, которые  по  полям  **funct3**  и  **funct7**  инструкции  RISC-V  однозначно определяют операцию. Например, для типа *S* словарь имеет следующий вид:  
```
public static final Map<Pair<Integer, Integer>, String> *FmtS* = Map.*ofEntries*(         *entry*(new Pair<>(0, 0), "sb"), 

        *entry*(new Pair<>(0x1, 0), "sh"), 

        *entry*(new Pair<>(0x2, 0), "sw") 

); 
```
**Парсинг** 

Берём аргументы командной строки, если мало — ошибка. Проверяем наличие файлов читки и записи, если кого-то не существует — ошибка. Далее читаем поток байтов в массив Constants.bytes, преобразуем из signed byte в положительный long. Даём классу Header прочитать свои 52 байта и выделить  поля,  проверяем  некоторые  из  них,  такие  как  первые  четыре **магических**  бита,  тип  архитектуры,  размер  заголовка,  если  что-то  не совпадает — ошибка. 

Далее, читаем все заголовки секций классами SectionHeader, ищем их настоящие имена в *.strtab*, который лежит по позиции найденного ранее поля e\_shstrndx из заголовка файла. Для удобства ложим каждую секцию в словарь по ключу имени из *.strtab* и значению самого класса секции. 

Далее, достанем из этого словаря секции  *.strtab* и *.symtab*. Теперь можно достать все символы классом Symbol из *.symtab* и соответствующие им имена из *.strtab*. Также добавим символы в словарь для дальнейшего использования инструкиями.  

Теперь  можно  достать  секцию  *.text*,  где  собственно  и  будет выполняться само дизассемблирование. Выделяя по четыре байта, передаем парсинг  классу  Instruction,  который,  используя  словари  **FMT**  типов, определяет  операции  и  читает  их  поля  соответствующе  своему  типу. Определив тип, он находит имена используемых регистров. Если вдруг это инструкция, подразумевающая переход (типа *B* или *J*), то необходимо ещё проверить наличие метки (символа из *.symtab*) в словаре (про который было сказано выше) по адресу с переходом. Если её нет, то добавим её в словарь по заданному правилу, после чего увеличим счётчик этих локальных меток. Добавим инструкцию в список чтобы в конце вывести их все. 

Для вывода сначала проходим по списку символов (не словарю с добавленными  дополнительно  локальными  метками,  а  именно изначальному списку из *.symtab*), выводим каждый по заданному шаблону. Далее берём список инструкций. Если вдруг адрес инструкции указывает на адрес  метки  в  словаре,  то  выводим  её.  Независимо  от  наличия  метки выводим саму инструкцию согласно её типу и заданному формату.  

В процессе всех действий в случае любой непонятной ситуации резко бросаем ошибку. 

**Компиляция и запуск** Компиляцию можно произвести командой ***javac Main.java*** 

Запуск командой ***java Main rv3 input\_file output\_file*** 

**Результат работы на заданном файле** 
```
.text 

00010074   <main>: 

   10074:  ff010113   addi sp, sp -16 

   10078:  00112623     sw ra, 12(sp) 

   1007c:  030000ef    jal ra, 0x100ac <mmul>    10080:  00c12083     lw ra, 12(sp) 

   10084:  00000513   addi a0, zero 0 

   10088:  01010113   addi sp, sp 16 

   1008c:  00008067   jalr zero, 0(ra) 

   10090:  00000013   addi zero, zero 0 

   10094:  00100137    lui sp, 256 

   10098:  fddff0ef    jal ra, 0x10074 <main>    1009c:  00050593   addi a1, a0 0 

   100a0:  00a00893   addi a7, zero 10 

   100a4:  0ff0000f  unknown\_instruction    100a8:  00000073  ecall 

000100ac   <mmul>: 

   100ac:  00011f37    lui t5, 17 

   100b0:  124f0513   addi a0, t5 292 

   100b4:  65450513   addi a0, a0 1620 

   100b8:  124f0f13   addi t5, t5 292 

   100bc:  e4018293   addi t0, gp -448 

   100c0:  fd018f93   addi t6, gp -48 

   100c4:  02800e93   addi t4, zero 40 000100c8   <L2>: 

   100c8:  fec50e13   addi t3, a0 -20 

   100cc:  000f0313   addi t1, t5 0 

   100d0:  000f8893   addi a7, t6 0 

   100d4:  00000813   addi a6, zero 0 000100d8   <L1>: 

   100d8:  00088693   addi a3, a7 0 

   100dc:  000e0793   addi a5, t3 0 

   100e0:  00000613   addi a2, zero 0 

000100e4   <L0>: 

   100e4:  00078703     lb a4, 0(a5) 

   100e8:  00069583     lh a1, 0(a3) 

   100ec:  00178793   addi a5, a5 1 

   100f0:  02868693   addi a3, a3 40 

   100f4:  02b70733    mul a4, a4, a1 

   100f8:  00e60633    add a2, a2, a4 

   100fc:  fea794e3    bne a5, a0 0x100e4 <L0> 

   10100:  00c32023     sw a2, 0(t1) 

   10104:  00280813   addi a6, a6 2 

   10108:  00430313   addi t1, t1 4 

   1010c:  00288893   addi a7, a7 2 

   10110:  fdd814e3    bne a6, t4 0x100d8 <L1> 

   10114:  050f0f13   addi t5, t5 80 

   10118:  01478513   addi a0, a5 20 

   1011c:  fa5f16e3    bne t5, t0 0x100c8 <L2> 

   10120:  00008067   jalr zero, 0(ra) 

Symbol Value           Size Type   Bind   Vis    Index Name 

[   0] 0x0                   0 NOTYPE   LOCAL    DEFAULT   UNDEF  

[   1] 0x10074               0 SECTION  LOCAL    DEFAULT       1  

[   2] 0x11124               0 SECTION  LOCAL    DEFAULT       2  

[   3] 0x0                   0 SECTION  LOCAL    DEFAULT       3  

[   4] 0x0                   0 SECTION  LOCAL    DEFAULT       4  

[   5] 0x0                   0 FILE     LOCAL    DEFAULT     ABS test.c 

[   6] 0x11924               0 NOTYPE   GLOBAL   DEFAULT     ABS \_\_global\_pointer$ [   7] 0x118F4             800 OBJECT   GLOBAL   DEFAULT       2 b 

[   8] 0x11124               0 NOTYPE   GLOBAL   DEFAULT       1 \_\_SDATA\_BEGIN\_\_ [   9] 0x100AC             120 FUNC     GLOBAL   DEFAULT       1 mmul 

[  10] 0x0                   0 NOTYPE   GLOBAL   DEFAULT   UNDEF \_start 

[  11] 0x11124            1600 OBJECT   GLOBAL   DEFAULT       2 c 

[  12] 0x11C14               0 NOTYPE   GLOBAL   DEFAULT       2 \_\_BSS\_END\_\_ 

[  13] 0x11124               0 NOTYPE   GLOBAL   DEFAULT       2 \_\_bss\_start 

[  14] 0x10074              28 FUNC     GLOBAL   DEFAULT       1 main 

[  15] 0x11124               0 NOTYPE   GLOBAL   DEFAULT       1 \_\_DATA\_BEGIN\_\_ [  16] 0x11124               0 NOTYPE   GLOBAL   DEFAULT       1 \_edata 

[  17] 0x11C14               0 NOTYPE   GLOBAL   DEFAULT       2 \_end 

[  18] 0x11764             400 OBJECT   GLOBAL   DEFAULT       2 a 
```
**Список источников** 

[https://en.wikipedia.org/wiki/RISC-V ](https://en.wikipedia.org/wiki/RISC-V)

[https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-](https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi.html)

[vi.html ](https://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi.html)

[https://github.com/jameslzhu/riscv-card/blob/master/riscv-card.pdf ](https://github.com/jameslzhu/riscv-card/blob/master/riscv-card.pdf)[https://refspecs.linuxbase.org/elf/gabi4+/ch4.symtab.html ](https://refspecs.linuxbase.org/elf/gabi4+/ch4.symtab.html)[https://en.wikipedia.org/wiki/Instruction_set_architecture ](https://en.wikipedia.org/wiki/Instruction_set_architecture)

[https://riscv.org/technical/specifications/ ](https://riscv.org/technical/specifications/)
